from django.conf import settings
import json
import feedparser
from langchain_core.prompts import ChatPromptTemplate
from .ai_output_schema import blog_schema_v2
from .models import UserMessage, ModelMessage
from admin_panal.models import BlogPost, Tags, BlogUrl
import uuid
from itertools import chain
from django.db import transaction
# from celery import shared_task


"""
This module contains the logic for generating blog posts based on an RSS feed.

The module works by:

1. Fetching an RSS feed from a randomly selected URL from the `BlogUrl` table.
2. Converting the RSS feed into a structured format for the Language Chain AI model.
3. Passing the structured data to the Language Chain AI model, which generates a blog post.
4. Saving the generated blog post to the `BlogPost` table, along with any new tags
   that were generated by the AI model.

The `fetch_feed` function fetches an RSS feed from a randomly selected URL from the
`BlogUrl` table. It returns the feed, as well as a `UserMessage` object that represents
the user's request for the feed.

The `ask_llm` function takes the feed and a `UserMessage` object, and asks the Language
Chain AI model to generate a blog post based on the feed. It returns a structured
representation of the blog post, including the title, summary, sections, external
links, and tags.

The `save_blog_posts` function takes a list of structured blog posts and saves them
to the `BlogPost` table. It also saves any new tags that were generated by the AI
model to the `Tags` table.

The module uses the `langchain_google_genai` library to interact with the Language
Chain AI model. The AI model is configured using the `settings.AI_MODEL` variable.

The module also uses the `django.db` library to interact with the database. The
`BlogUrl` and `BlogPost` models are defined in the `admin_panal` app, and the
`UserMessage` and `ModelMessage` models are defined in the `models` module of this
app.

The module uses the `transaction` library to ensure that all database operations are
atomic. If any of the operations fail, the entire transaction is rolled back.

The module uses the `itertools` library to chain together multiple iterables.

The module uses the `uuid` library to generate unique IDs for each blog post.
"""

# @shared_task
def fetch_feed():
    """
    Fetch an RSS feed from a randomly selected URL from the `BlogUrl` table.

    Returns:
        tuple: A tuple containing the feed and a `UserMessage` object that represents
            the user's request for the feed.
    """
    url_obj = BlogUrl.objects.order_by("?").first()
    if not url_obj:
        return None
    url = url_obj.url
    feed = feedparser.parse(url)

    user_message = UserMessage.objects.create(
        url=url,
        raw_data=json.dumps(feed),
        model_used=settings.AI_MODEL
    )
    # return {"feed": feed, "user_message": user_message.pk}
    return feed, user_message


# @shared_task
def ask_llm(feed, user_message) -> dict:
    """
    Ask the Language Chain AI model to generate a blog post based on the feed.

    Args:
        feed: The RSS feed to generate a blog post for.
        user_message: The `UserMessage` object that represents the user's request for
            the feed.
        llm: The Language Chain AI model to use.

    Returns:
        dict: A structured representation of the blog post, including the title,
            summary, sections, external links, and tags.
    """
    # if result is None:
    #     return None

    # feed = result["feed"]
    # user_message = result["user_message"]
    llm = settings.LLM

    prompt_template = ChatPromptTemplate.from_messages(
        [
            ("system", "You are an expert content writer and blog generator."),
            ("human",
             """
            Analyze the provided RSS feed data and the links associated with each topic. For each topic, generate a professional-quality blog post by researching additional context using the provided external links.

            Return each blog post as a **well-formatted markdown document** that includes:

            - A compelling **title** (formatted with `#` in markdown).
            - A concise and informative **summary** paragraph.
            - Multiple **sections**, each with:
            - A markdown subheading (`##` or `###`)
            - 3â€“4 paragraphs of detailed, engaging content
            - Any relevant bullet points, inline formatting, or blockquotes
            - A list of **external links** used, formatted as markdown: `[Link Title](https://example.com)`
            - A list of **relevant tags** at the end (formatted like a tag list)

            Format the entire content strictly in **markdown**, using appropriate syntax for:
            - Headings
            - Paragraphs
            - Lists
            - Emphasis (e.g., `**bold**`, `*italic*`)
            - External links

            Ensure the tone is professional and easy to read, and that the blog post delivers value to readers. The content should read like it belongs on a high-quality tech or business blog.
            """
             ),
            ("human", "RSSFeed: {feed}."),
        ]
    )

    structured_llm = llm.with_structured_output(blog_schema_v2)
    chain = prompt_template | structured_llm
    response = chain.invoke({"feed": str(feed)})

    model_message = ModelMessage.objects.create(
        parent=user_message,
        content=json.dumps(response),
        model_used=settings.AI_MODEL
    )

    return response


# @shared_task
def save_blog_posts(data: list):
    """
    Save the generated blog posts to the `BlogPost` table, along with any new tags
    that were generated by the AI model.

    Args:
        data: A list of structured blog posts to save.
    """
    print('DATA: ', data)
    if data is None:
        return
    existing_tags = set(Tags.objects.all().values_list("name", flat=True))
    new_tags = {}
    posts_tags = {}
    new_posts = {}
    for post in data:
        uid = uuid.uuid4()
        post_tags = list(
            map(lambda tag: tag.lower().replace(" ", "-"), post.get("tags", [])))
        tags = [Tags(name=tag)
                for tag in post_tags if tag not in existing_tags]
        new_tags[uid] = tags
        new_posts[uid] = BlogPost(**post)
        posts_tags[uid] = post_tags
    with transaction.atomic():
        created_posts = BlogPost.objects.bulk_create(new_posts.values())
        Tags.objects.bulk_create(chain.from_iterable(new_tags.values()))

        all_tag_names = set(chain.from_iterable(posts_tags.values()))
        all_tags = Tags.objects.filter(name__in=all_tag_names)
        tag_map = {tag.name: tag for tag in all_tags}

        uid_to_post = dict(zip(new_posts.keys(), created_posts))

        for uid, post in uid_to_post.items():
            tags = [tag_map[name]
                    for name in posts_tags[uid] if name in tag_map]
            post.tags.add(*tags)


